
===== BEGIN src/empfaenger/Schwellwerte.rtf =====
{\rtf1\ansi\ansicpg1252\cocoartf2639
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Times-Roman;\f1\froman\fcharset0 Times-Bold;\f2\fmodern\fcharset0 Courier;
\f3\ftech\fcharset77 Symbol;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid201\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid3}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}}
\paperw11900\paperh16840\margl1440\margr1440\vieww33400\viewh17940\viewkind0
\deftab720
\pard\pardeftab720\sa240\partightenfactor0

\f0\fs24 \cf0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Perfekt, das Ergebnis (alle ~1050 \'96 egal ob 2.2 \uc0\u937 , 3.3 \u937 , 100 \u937 ) ist v\'f6llig ok. Dein Messaufbau erkennt \'84
\f1\b Last vorhanden
\f0\b0 \'93 \'96 nicht die genaue Ohmzahl. Damit k\'f6nnen wir eine robuste Schwelle setzen.\
\pard\pardeftab720\sa298\partightenfactor0

\f1\b\fs36 \cf0 \strokec2 Empfehlung Schwelle (5-V-Messmodus, 24 V AUS)\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\partightenfactor0
\ls1\ilvl0
\fs24 \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Ein-Schwelle (ON):
\f0\b0  
\f2\fs26 raw > 700
\f0\fs24 \
\ls1\ilvl0
\f1\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Aus-Schwelle (OFF):
\f0\b0  
\f2\fs26 raw < 200
\f0\fs24 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\partightenfactor0
\ls1\ilvl0\cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Dazwischen: Zustand halten (Hysterese)\
\pard\pardeftab720\sa240\partightenfactor0
\cf0 Damit hast du viel Luft zu \'84offen\'93 (typ. 0\'8510) und genug Abstand zu \'84Last\'93 (~1050).\
\pard\pardeftab720\sa280\partightenfactor0

\f1\b\fs28 \cf0 Mini-Patch (nur die Klassifizierung ersetzen)\
\pard\pardeftab720\partightenfactor0

\f2\b0\fs26 \cf0 // ---- Klassifizieren ----\
bool clamp = (vy >= TH_ZENER_VY);     // 24V/Clamp? -> niemals "Durchgang"\
static bool state[8] = \{0\};           // Hysterese-Speicher pro Kanal\
\
if (!clamp) \{\
  if (raw > 700) state[ch] = true;    // EIN-Schwelle\
  else if (raw < 200) state[ch] = false; // AUS-Schwelle\
  // sonst Zustand halten\
\} else \{\
  state[ch] = false;                  // Clamp z\'e4hlt als "offen"\
\}\
\
bool connected = state[ch];\
\pard\pardeftab720\sa240\partightenfactor0

\f0\fs24 \cf0 (Deine Ausgabe/LED-Maske nutzt dann 
\f2\fs26 connected
\f0\fs24  statt der alten Logik.)\
\pard\pardeftab720\sa298\partightenfactor0

\f1\b\fs36 \cf0 \strokec2 Was die 1050 bedeuten\
\pard\pardeftab720\sa240\partightenfactor0

\f0\b0\fs24 \cf0 \strokec2 Mit deinen aktuellen 5-V-Bedingungen ergibt sich am ADC etwa:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\partightenfactor0
\ls2\ilvl0
\f2\fs26 \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Vadc \uc0\u8776  0.85 V
\f0\fs24  
\f3 \uc0\u8594 
\f0  
\f2\fs26 raw \uc0\u8776  1050
\f0\fs24 \
\ls2\ilvl0
\f2\fs26 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Vy \uc0\u8776  1.6 V
\f0\fs24  (wegen 
\f2\fs26 DIV_GAIN=1.879
\f0\fs24 )\uc0\u8232 Das ist absolut fein \'96 Hauptsache, 
\f1\b deutlich
\f0\b0  \'fcber \'84offen\'93.\
\pard\pardeftab720\sa298\partightenfactor0

\f1\b\fs36 \cf0 \strokec2 Widerst\'e4nde behalten?\
\pard\pardeftab720\sa240\partightenfactor0

\f0\b0\fs24 \cf0 \strokec2 F\'fcrs weitere Testen reichen:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\partightenfactor0
\ls3\ilvl0
\f1\b \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 2.2 \uc0\u937 
\f0\b0  (Z\'fcnder-Ersatz / Worst-Case)\
\ls3\ilvl0
\f1\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 100 \uc0\u937 
\f0\b0  (sch\'f6ne Referenz f\'fcr 5-V-Messung)\
\ls3\ilvl0
\f1\b \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 560 \uc0\u937 
\f0\b0  (oberes Ende)\uc0\u8232 Alles andere kannst du gern zur\'fcckgeben \'96 f\'fcr die Erkennung bringt\'92s kaum Mehrwert.\
\pard\pardeftab720\sa240\partightenfactor0
\cf0 Und wie gehabt: Sobald 
\f1\b 24 V
\f0\b0  anliegen, greift die 
\f1\b Clamp-Erkennung
\f0\b0  (
\f2\fs26 Vy > 4.3 V
\f0\fs24 ) und es wird 
\f1\b nie
\f0\b0  \'84Durchgang\'93 gemeldet, bis tats\'e4chlich gefeuert wird.\
R}
===== END src/empfaenger/Schwellwerte.rtf =====

===== BEGIN src/empfaenger/ZuendpulsEv1.ino =====
#include "config.h"
#include "mapping.h"
#include "leds.h"
#include "mux.h"
#include "sense.h"
#include "power.h"
#include "display.h"
#include "buzzer.h"
#include "radio.h"
#include "temp.h"
#include "heater.h"
#include "battery.h"



// Software-ARM (ohne Taster)
static bool armed = false;
static uint32_t sense_start_ms = 0;
static uint32_t ui_tick_ms = 0;

static uint8_t  ui_page    = 0;      // 0=BOX, 1=BAT, 2=COUNT
static uint32_t ui_page_ms = 0;

static float     g_last_tempC = 0.0f;

static void buzzer_triple(){ buzzer_beep(80); delay(80); buzzer_beep(80); delay(80); buzzer_beep(120); }

static void set_armed(bool make_armed){
  if (make_armed == armed) return;

  if (make_armed){
    // Deep-Voltage Check
    float v = battery_read_voltage();
    if (v < FIRE_INHIBIT_V){
      Serial.print("ARM VERWEIGERT: Akku zu niedrig (");
      Serial.print(v,2); Serial.println(" V).");
      buzzer_triple();
      // Anzeige aktualisieren bleibt SAFE
      return;
    }
    // -> ARMED
    armed = true;
    heater_set_kill(true);     // <--- Heizung sofort AUS
    sense_stop(!LED_KEEP_WHEN_ARMED);
    delay(5);
    power_set_24v(true);
    buzzer_pattern_armed();
    Serial.println("-> ARMED: Sense AUS, 24V EIN, HEATER AUS.");
  } else {
    // -> SAFE
    armed = false;
    power_set_24v(false);
    delay(20);
    leds_tristate_outputs(false);
    sense_enable();
    sense_start_ms = millis();
    buzzer_pattern_safe();
    Serial.println("-> SAFE: 24V AUS, Sense EIN.");
  }
}

static void print_help(){
  Serial.println("\n=== Steuerung ===");
  Serial.println("  a -> ARMED (Sense AUS, 24V EIN)");
  Serial.println("  s -> SAFE  (24V AUS, Sense EIN)");
  Serial.println("  h -> Hilfe");
}

void setup(){
  Serial.begin(115200);

  power_begin();        // 24V AUS
  mux_begin();
  leds_begin();
  display_begin();
  battery_begin();
  buzzer_begin();
  radio_begin();
  temp_begin();
  heater_begin();               // Heizung standardmäßig erlaubt (Default laut Config)
  heater_reset_preheat_timer(); // Vorwärm-Timer starten

  // Wenn du möchtest, nach dem Boot wieder freigeben:
  heater_set_kill(false);  // optional: Heizung frei nach Init

  leds_selftest(SELFTEST_MS);
  display_show_boot("OLED/Batt/RF OK");

  // Start SAFE
  sense_begin();
  sense_start_ms = millis();
  set_armed(false);

  ui_tick_ms = millis();
  Serial.print("Auto-Stop in "); Serial.print(SENSE_TIMEOUT_MS/1000); Serial.println(" s.");
  print_help();
}

void loop(){
  // serielle Umschaltung optional
  while (Serial.available()){
    char c = (char)Serial.read();
    if (c=='a'||c=='A'){ set_armed(true); }
    else if (c=='s'||c=='S'){ set_armed(false); }
    else if (c=='h'||c=='H'){ print_help(); }
  }

  // Sense/Timeout
  if (!armed){
    if (millis() - sense_start_ms < SENSE_TIMEOUT_MS){
      sense_scan_once();
      delay(80);
    } else {
      sense_stop(!LED_KEEP_AFTER_SENSE);
      delay(200);
    }
  } else {
    delay(80);
  }

  // Akku-Warnung (Ticken), max alle 2 s
  static uint32_t lowbat_tick_ms = 0;
  if (battery_low()){
    if (millis() - lowbat_tick_ms > 2000){
      buzzer_tick_lowbat();
      lowbat_tick_ms = millis();
    }
  }

  // Heizer-Automatik (alle ~500 ms)
static uint32_t last_mgr = 0;
if (millis() - last_mgr > 500){
  float v  = battery_read_voltage();
  g_last_tempC = temp_read_c();
  heater_manage(armed, g_last_tempC, v);
  last_mgr = millis();
}

// OLED: Seite alle 2000 ms weiterblättern, Redraw alle 250 ms
uint32_t now = millis();
if (now - ui_page_ms > 2000){
  ui_page = (ui_page + 1) % 4;   // jetzt 4 Seiten: 0..3
  ui_page_ms = now;
}
static uint32_t ui_draw_ms = 0;
if (now - ui_draw_ms > 250){
  int   pct = battery_percent();
  float v   = battery_read_voltage();
  int   cnt = sense_count_connected();
  bool  heatOn = !heater_is_killed();
  display_show_page(ui_page, BOX_CHANNEL, pct, v, armed, cnt, 30, g_last_tempC, heatOn);
  ui_draw_ms = now;
}
}


===== END src/empfaenger/ZuendpulsEv1.ino =====

===== BEGIN src/empfaenger/battery.h =====
#pragma once
#include <Arduino.h>
#include "config.h"

void  battery_begin();
float battery_read_voltage();          // Vbat in Volt
int   battery_percent();               // 0..100
bool  battery_low();                   // Warnung aktiv (mit Hysterese)

===== END src/empfaenger/battery.h =====

===== BEGIN src/empfaenger/battery.cpp =====
#include "battery.h"

static bool s_low = false;

void battery_begin(){
  pinMode(BAT_ADC_PIN, INPUT);
  analogReadResolution(ADC_BITS);
  analogReadAveraging(8);
}

static float adc_to_vbat(int raw){
  float v_adc = (raw / ADC_MAX) * VREF_ADC;
  float div_gain = (BAT_R_TOP + BAT_R_BOT) / BAT_R_BOT;
  return v_adc * div_gain;
}

float battery_read_voltage(){
  long acc=0;
  for(int i=0;i<16;i++){ acc += analogRead(BAT_ADC_PIN); delayMicroseconds(150); }
  int raw = acc / 16;
  return adc_to_vbat(raw);
}

int battery_percent(){
  float v = battery_read_voltage();
  if (v <= BAT_V_MIN) return 0;
  if (v >= BAT_V_MAX) return 100;
  return int( (v - BAT_V_MIN) * 100.0f / (BAT_V_MAX - BAT_V_MIN) + 0.5f );
}

bool battery_low(){
  float v = battery_read_voltage();
  if (!s_low && v <= BAT_V_WARN) s_low = true;
  else if (s_low && v >= BAT_V_CLEAR) s_low = false;
  return s_low;
}

===== END src/empfaenger/battery.cpp =====

===== BEGIN src/empfaenger/buzzer.h =====
#pragma once
#include <Arduino.h>
#include "config.h"

void buzzer_begin();
void buzzer_beep(uint16_t ms);
void buzzer_pattern_armed();      // kurzes Muster bei ARMED
void buzzer_pattern_safe();       // kurzes Muster bei SAFE
void buzzer_tick_lowbat();        // kurzer Tick bei LowBatt

===== END src/empfaenger/buzzer.h =====

===== BEGIN src/empfaenger/buzzer.cpp =====
#include "buzzer.h"

void buzzer_begin(){
  pinMode(BUZZER_PIN, OUTPUT);
  digitalWrite(BUZZER_PIN, LOW);
}

void buzzer_beep(uint16_t ms){
  digitalWrite(BUZZER_PIN, HIGH);
  delay(ms);
  digitalWrite(BUZZER_PIN, LOW);
}

void buzzer_pattern_armed(){
  buzzer_beep(120); delay(100); buzzer_beep(200);
}
void buzzer_pattern_safe(){
  buzzer_beep(80); delay(60); buzzer_beep(80);
}
void buzzer_tick_lowbat(){
  buzzer_beep(30);
}

===== END src/empfaenger/buzzer.cpp =====

===== BEGIN src/empfaenger/config.h =====
#pragma once
#include <Arduino.h>

// ===== LED-Ketten-Layout =====
constexpr bool LED_FIRST      = false; // false = [FIRE][LED] (dein Board)
constexpr bool LED_ACTIVE_LOW = false;  // LED leuchtet bei 0

// ===== ADC / Physik =====
constexpr int   ADC_BITS    = 12;
constexpr float VREF_ADC    = 3.3f;
constexpr float DIV_GAIN    = 1.879f;               // Vy = Vadc * DIV_GAIN
constexpr float TH_ZENER_VY = 4.3f;                 // Clamp-Erkennung
constexpr float ADC_MAX     = float((1 << ADC_BITS) - 1);

// ===== Erkennung (5V-Messmodus) =====
constexpr int RAW_ON  = 700;                        // Ein-Schwelle
constexpr int RAW_OFF = 200;                        // Aus-Schwelle

// ===== Pin-Map =====
struct Bus { int ser, clk, rclk; };

constexpr int BOARDS = 4;
constexpr int CH_PER = 8;
constexpr int TOTAL  = BOARDS * CH_PER;
constexpr int TOTAL_CH = TOTAL;                     // Alias

// Shiftregister-Busse (pro Board)
constexpr Bus SR[BOARDS] = {
  {32,33,34},  // Board 0 -> ZK 1..8
  {35,36,37},  // Board 1 -> ZK 9..16
  {38,39,40},  // Board 2 -> ZK 17..24
  {15,16,17}   // Board 3 -> ZK 25..32
};
constexpr int SR_OE_PIN = 12;                       // 74HC595 OE# (aktiv-LOW, gemeinsam)
constexpr int PIN_BTS   = 20;                       // 24V Enable (LOW = AUS)

// MUX
constexpr int PIN_MUX_A0 = 21, PIN_MUX_A1 = 22, PIN_MUX_A2 = 23;
constexpr int PIN_MUX_E[BOARDS] = {28,29,30,31};    // LOW = aktiv je Board
constexpr int PIN_MUX_Z[BOARDS] = {24,25,26,27};    // ADC-Eingänge je Board

// ===== Soft-Shift (ohne Serien-R: Kanten entschärfen) =====
constexpr uint8_t SHIFT_US       = 2;
constexpr uint8_t LATCH_GUARD_US = 5;

// ===== Betriebs-Optionen =====
constexpr uint32_t SELFTEST_MS          = 2500;     // Dauer LED-Selftest beim Boot
constexpr uint32_t SENSE_TIMEOUT_MS     = 180000;   // 3 min Messzeit
constexpr bool     LED_KEEP_AFTER_SENSE = true;     // true: LED-Latch bleibt an

// ===== ARMED/SAFE Umschaltung =====
// Optionaler Hardware-Eingang für "scharf":
// -1 = deaktiviert (nur Software-Umschaltung), sonst Pin-Nummer eintragen.
// Aktiv-Logik: HIGH = scharf (bei interner PULLUP typ. Taster nach GND -> active-low ändern)
constexpr int  PIN_ARM          = -1;     // z.B. 14 wenn du einen Schalter am Teensy nutzt
constexpr bool ARM_ACTIVE_HIGH  = true;   // true: HIGH = scharf, false: LOW = scharf
constexpr bool LED_KEEP_WHEN_ARMED = false;// wenn scharf -> Messung AUS; LEDs anlassen?


// ===== Auto-Fire-Demo (Trockenlauf) =====
constexpr bool     AUTO_FIRE_DEMO       = false;   // Autostart-Demo aktiv
constexpr uint32_t START_ARM_DELAY_MS   = 3000;   // 3 s bis ARMED
constexpr uint32_t FIRE_PULSE_MS        = 1000;   // Pulsdauer je Kanal
constexpr uint32_t FIRE_GAP_MS          = 400;    // Pause zwischen Kanälen

// ===== Buzzer / Batterie / Funk =====
constexpr int  BUZZER_PIN     = 6;

// Batterie-ADC (Teensy A0 = Pin 14)
constexpr int   BAT_ADC_PIN   = 14;
// Teiler (ANPASSEN!): Vbat -- R_TOP --(ADC)-- R_BOT -- GND
constexpr float BAT_R_TOP  = 100000.0f; // 100k
constexpr float BAT_R_BOT  = 12000.0f;  // 12k

// LiFePO₄ 8s
constexpr float BAT_V_MIN  = 22.0f;     // leer (unter Last)
constexpr float BAT_V_MAX  = 29.2f;     // voll
constexpr float BAT_V_WARN = 24.0f;     // Warnung
constexpr float BAT_V_CLEAR= 24.6f;     // Hysterese



// Funk-Pins (E32/LoRa-Style: M0/M1/AUX + UART)
constexpr int  RADIO_RX_PIN   = 0;   // Teensy RX1
constexpr int  RADIO_TX_PIN   = 1;   // Teensy TX1
constexpr int  RADIO_AUX_PIN  = 2;   // AUX (Input)
constexpr int  RADIO_M0_PIN   = 3;   // M0  (Output)
constexpr int  RADIO_M1_PIN   = 4;   // M1  (Output)
constexpr long RADIO_BAUD     = 9600;

// Box-Kanal/ID (nur Anzeige erstmal)
constexpr uint8_t BOX_CHANNEL = 1;   // <- deine Box-ID/Ansprechkanal eintragen


// ===== Deep-Voltage Schutz fürs ARMED (hast du schon) =====
constexpr float FIRE_INHIBIT_V = 20.5f;   // darunter kein ARMED

// ===== Temperatur / Heizung (Auto) =====
constexpr int   TEMP_ADC_PIN             = 41;     // ADC für Temperatur
constexpr bool  TEMP_USE_TMP36           = true;
constexpr float TEMP_MV_OFFSET           = 500.0f;
constexpr float TEMP_MV_PER_C            = 10.0f;

// Heizen: Hysterese (z.B. unter 5°C ein, über 15°C aus)
constexpr float TEMP_HEAT_ON_C           = 5.0f;
constexpr float TEMP_HEAT_OFF_C          = 15.0f;

// Akku-Wächter fürs Heizen (nicht unter X Volt leer saugen)
constexpr float HEAT_MIN_V_RUN           = 23.6f;  // darunter Heizen AUS
constexpr float HEAT_RESUME_V            = 24.2f;  // erst ab hier wieder erlauben

// Safety: max. Vorwärmzeit
constexpr uint32_t HEAT_MAX_PREHEAT_MS   = 15UL * 60UL * 1000UL; // 15 min

// Verhalten
constexpr bool HEATER_AUTOKILL_EN        = true;   // Auto-Logik aktiv
constexpr int  HEATER_KILL_PIN           = 11;     // Kill-Leitung zur Heizung
constexpr bool HEATER_KILL_ACTIVE_HIGH   = true;   // HIGH = Heizung AUS

// WICHTIG: Default beim Einschalten (falls Teensy tot/kalt): Heizung EIN
constexpr bool HEATER_DEFAULT_ON_AT_BOOT = true;   // default: heizen erlaubt
constexpr bool HEATER_FORCE_OFF_WHEN_ARMED = true; // bei ARMED immer Heizung AUS

===== END src/empfaenger/config.h =====

===== BEGIN src/empfaenger/display.h =====
#pragma once
#include <Arduino.h>

void display_begin();
void display_show_boot(const char* msg);

// page: 0=BOX, 1=BAT, 2=COUNT, 3=TEMP/HEAT
void display_show_page(uint8_t page,
                       uint8_t boxChannel,
                       int batPct, float vbat,
                       bool armed,
                       int connected, int maxZ,
                       float tempC, bool heatOn);

===== END src/empfaenger/display.h =====

===== BEGIN src/empfaenger/display.cpp =====
#include "display.h"
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

static const int SCREEN_WIDTH  = 128;
static const int SCREEN_HEIGHT = 64;
static const uint8_t I2C_ADDR  = 0x3C;

static Adafruit_SSD1306 oled(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);

static int tW(const char* s, uint8_t sz){ int n=0; while(*s){n++; s++;} return n*6*sz; }
static int tH(uint8_t sz){ return 8*sz; }
static void printCentered(const char* s, int y, uint8_t sz){
  int x = (SCREEN_WIDTH - tW(s,sz))/2; if (x<0) x=0;
  oled.setCursor(x,y); oled.setTextSize(sz); oled.print(s);
}

void display_begin(){
  Wire.begin(); Wire.setClock(400000);
  oled.begin(SSD1306_SWITCHCAPVCC, I2C_ADDR);
  oled.clearDisplay(); oled.setTextColor(SSD1306_WHITE); oled.display();
}

void display_show_boot(const char* msg){
  oled.clearDisplay();
  oled.fillRect(0,0,SCREEN_WIDTH,16, SSD1306_WHITE);
  oled.setTextColor(SSD1306_BLACK);
  printCentered("Zundsystem", 4, 1);
  oled.setTextColor(SSD1306_WHITE);
  printCentered("Selftest...", 26, 2);
  if (msg && *msg) printCentered(msg, 50, 1);
  oled.display();
}

static void badge(bool armed){
  const char* s = armed ? "ARMED" : "SAFE";
  int w = 6 * (armed?5:4) + 8;
  oled.drawRect(0,0,w,14, SSD1306_WHITE);
  oled.setCursor(4,3); oled.setTextSize(1); oled.print(s);
}

void display_show_page(uint8_t page,
                       uint8_t boxChannel,
                       int batPct, float vbat,
                       bool armed,
                       int connected, int maxZ,
                       float tempC, bool heatOn){
  if (batPct<0) batPct=0; if (batPct>100) batPct=100;
  if (connected<0) connected=0; if (connected>maxZ) connected=maxZ;

  oled.clearDisplay();
  badge(armed);

  if (page == 0){
    // BOX
    char buf[16];
    snprintf(buf,sizeof(buf),"BOX %d", boxChannel);
    printCentered(buf, 22, 3);

  } else if (page == 1){
    // BAT
    char pbuf[16]; snprintf(pbuf,sizeof(pbuf), "%d%%", batPct);
    printCentered(pbuf, 18, 3);
    char vbuf[16]; snprintf(vbuf,sizeof(vbuf), "%.1fV", vbat);
    printCentered(vbuf, SCREEN_HEIGHT - tH(2) - 2, 2);

  } else if (page == 2){
    // COUNT
    char cbuf[24]; snprintf(cbuf,sizeof(cbuf), "ZUNDER %d/%d", connected, maxZ);
    printCentered(cbuf, 22, 2);

  } else {
    // TEMP / HEAT
    char tbuf[16]; snprintf(tbuf,sizeof(tbuf), "%.0f\xB0""C", tempC); // große °C
    printCentered(tbuf, 14, 3);
    char hbuf[16]; snprintf(hbuf,sizeof(hbuf), "HEAT:%s", heatOn ? "ON" : "OFF");
    printCentered(hbuf, SCREEN_HEIGHT - tH(2) - 2, 2);
  }

  oled.display();
}

===== END src/empfaenger/display.cpp =====

===== BEGIN src/empfaenger/fire.h =====
#pragma once
#include <Arduino.h>
#include "config.h"

void fire_begin();
void fire_clear_all();                     // alle FIRE=0
void fire_pulse_ch(uint8_t ch, uint32_t ms, bool show_led); // ch=0..31
void fire_pulse_zk(uint8_t zk, uint32_t ms, bool show_led); // zk=1..32

===== END src/empfaenger/fire.h =====

===== BEGIN src/empfaenger/fire.cpp =====
#include "fire.h"
#include "mapping.h"
#include "leds.h"

static uint8_t fireMaskBoard[BOARDS] = {0,0,0,0};

void fire_begin(){
  for(int b=0;b<BOARDS;b++){ fireMaskBoard[b]=0; io_write_board(b, 0x00, 0x00); }
}

void fire_clear_all(){
  for(int b=0;b<BOARDS;b++){ fireMaskBoard[b]=0; io_write_board(b, 0x00, 0x00); }
}

void fire_pulse_ch(uint8_t ch, uint32_t ms, bool show_led){
  if (ch >= TOTAL_CH) return;
  int b = ch / CH_PER;
  int k = ch % CH_PER;
  uint8_t fireBit = (uint8_t)(1u<<k);
  uint8_t ledBit  = (uint8_t)(1u<<LED_MAP[b][k]);

  // Setzen
  fireMaskBoard[b] |= fireBit;
  io_write_board(b, fireMaskBoard[b], show_led ? ledBit : 0x00);

  delay(ms); // Pulsdauer

  // Rücksetzen
  fireMaskBoard[b] &= ~fireBit;
  io_write_board(b, fireMaskBoard[b], 0x00);
}

void fire_pulse_zk(uint8_t zk, uint32_t ms, bool show_led){
  if (zk < 1 || zk > 32) return;
  uint8_t ch = CH_FROM_ZK[zk-1];
  fire_pulse_ch(ch, ms, show_led);
}

===== END src/empfaenger/fire.cpp =====

===== BEGIN src/empfaenger/leds.h =====
#pragma once
#include <Arduino.h>
#include "config.h"

void leds_begin();
void leds_write_board(int b, uint8_t ledByte); // FIRE bleibt 0x00
void leds_all_off();
void leds_selftest(uint32_t duration_ms);
void leds_tristate_outputs(bool tristate);

// NEU: gleichzeitiges Schreiben von FIRE & LED für ein Board
void io_write_board(int b, uint8_t fireMask, uint8_t ledMask);

===== END src/empfaenger/leds.h =====

===== BEGIN src/empfaenger/leds.cpp =====
#include "leds.h"
#include "mapping.h"

static inline void sr_shift_byte(int ser,int clk,uint8_t v){
  for(int i=7;i>=0;--i){
    digitalWrite(ser,(v>>i)&1);
    delayMicroseconds(1);
    digitalWrite(clk,HIGH); delayMicroseconds(SHIFT_US);
    digitalWrite(clk,LOW);  delayMicroseconds(SHIFT_US);
  }
}

void leds_tristate_outputs(bool tristate){
  pinMode(SR_OE_PIN,OUTPUT);
  digitalWrite(SR_OE_PIN, tristate ? HIGH : LOW);
}

// === NEU: FIRE & LED gleichzeitig schreiben ===
void io_write_board(int b, uint8_t fireMask, uint8_t ledMask){
  uint8_t led = LED_ACTIVE_LOW ? (uint8_t)~ledMask : ledMask;
  leds_tristate_outputs(true);                 // OE HIGH
  delayMicroseconds(LATCH_GUARD_US);
  digitalWrite(SR[b].rclk,LOW);
  if (LED_FIRST){                              // [LED][FIRE]
    sr_shift_byte(SR[b].ser,SR[b].clk,led);
    sr_shift_byte(SR[b].ser,SR[b].clk,fireMask);
  } else {                                     // [FIRE][LED]
    sr_shift_byte(SR[b].ser,SR[b].clk,fireMask);
    sr_shift_byte(SR[b].ser,SR[b].clk,led);
  }
  delayMicroseconds(LATCH_GUARD_US);
  digitalWrite(SR[b].rclk,HIGH);
  delayMicroseconds(LATCH_GUARD_US);
  digitalWrite(SR[b].rclk,LOW);
  leds_tristate_outputs(false);                // OE LOW (sichtbar/aktiv)
}

void leds_begin(){
  leds_tristate_outputs(true); // Outputs AUS
  for(int b=0;b<BOARDS;b++){
    pinMode(SR[b].ser,OUTPUT); pinMode(SR[b].clk,OUTPUT); pinMode(SR[b].rclk,OUTPUT);
    digitalWrite(SR[b].ser,LOW); digitalWrite(SR[b].clk,LOW); digitalWrite(SR[b].rclk,LOW);
  }
  for(int b=0;b<BOARDS;b++) leds_write_board(b, 0x00);
}

void leds_write_board(int b, uint8_t ledByte){
  io_write_board(b, /*fire*/0x00, /*led*/ledByte);
}

void leds_all_off(){
  for(int b=0;b<BOARDS;b++) leds_write_board(b, 0x00);
}

// … (Selftest unverändert wie bei dir; benutzt LED_MAP)
void leds_selftest(uint32_t duration_ms){
  const uint32_t t0 = millis();
  // 1) Wipe pro Board vorwärts
  for(int b=0;b<BOARDS && millis()-t0 < duration_ms; ++b){
    for(int k=0;k<8 && millis()-t0 < duration_ms; ++k){
      uint8_t bit = LED_MAP[b][k];
      leds_write_board(b, (uint8_t)(1u<<bit));
      delay(50);
    }
    leds_write_board(b, 0x00);
  }
  // 2) Ping-Pong
  for(int r=0; r<2 && millis()-t0 < duration_ms; ++r){
    for(int step=0; step<8 && millis()-t0 < duration_ms; ++step){
      for(int b=0;b<BOARDS;++b){
        uint8_t bit = LED_MAP[b][step];
        leds_write_board(b, (uint8_t)(1u<<bit));
      }
      delay(60);
    }
    for(int step=6; step>0 && millis()-t0 < duration_ms; --step){
      for(int b=0;b<BOARDS;++b){
        uint8_t bit = LED_MAP[b][step];
        leds_write_board(b, (uint8_t)(1u<<bit));
      }
      delay(60);
    }
  }
  // 3) All-ON blink
  for(int n=0; n<2 && millis()-t0 < duration_ms; ++n){
    for(int b=0;b<BOARDS;++b) leds_write_board(b, 0xFF);
    delay(120);
    for(int b=0;b<BOARDS;++b) leds_write_board(b, 0x00);
    delay(120);
  }
}

===== END src/empfaenger/leds.cpp =====

===== BEGIN src/empfaenger/mapping.h =====
#pragma once
#include <stdint.h>

extern const uint8_t CH_FROM_ZK[32];
extern const uint8_t ZK_FROM_CH[32];
extern const uint8_t LED_MAP[4][8];

===== END src/empfaenger/mapping.h =====

===== BEGIN src/empfaenger/mapping.cpp =====
#include "mapping.h"

// Zündkanal (1..32) -> physischer CH (0..31)
const uint8_t CH_FROM_ZK[32] = {
   7,6,5,4,3,2,1,0,  15,14,13,12,11,10,9,8,
  23,22,21,20,19,18,17,16,  31,30,29,28,27,26,25,24
};
// physischer CH (0..31) -> Zündkanal (1..32)
const uint8_t ZK_FROM_CH[32] = {
   8,7,6,5,4,3,2,1,  16,15,14,13,12,11,10,9,
  24,23,22,21,20,19,18,17,  32,31,30,29,28,27,26,25
};

// LED-Mapping (lokaler Kanal k -> LED-Bit) – gespiegelt auf allen Boards
const uint8_t LED_MAP[4][8] = {
  {7,6,5,4,3,2,1,0},  // Board 0
  {7,6,5,4,3,2,1,0},  // Board 1
  {7,6,5,4,3,2,1,0},  // Board 2
  {7,6,5,4,3,2,1,0}   // Board 3
};

===== END src/empfaenger/mapping.cpp =====

===== BEGIN src/empfaenger/mux.h =====
#pragma once
#include <Arduino.h>
#include "config.h"

void mux_begin();
void mux_select(int board, int ch); // aktiviert nur dieses Board/ch
void mux_disable_all();

===== END src/empfaenger/mux.h =====

===== BEGIN src/empfaenger/mux.cpp =====
#include "mux.h"

static inline void muxAddr(uint8_t ch){
  digitalWrite(PIN_MUX_A0, ch & 1);
  digitalWrite(PIN_MUX_A1,(ch>>1)&1);
  digitalWrite(PIN_MUX_A2,(ch>>2)&1);
}

void mux_begin(){
  pinMode(PIN_MUX_A0,OUTPUT); pinMode(PIN_MUX_A1,OUTPUT); pinMode(PIN_MUX_A2,OUTPUT);
  for(int b=0;b<BOARDS;b++){ pinMode(PIN_MUX_E[b],OUTPUT); digitalWrite(PIN_MUX_E[b],HIGH); }
}
void mux_disable_all(){ for(int i=0;i<BOARDS;i++) digitalWrite(PIN_MUX_E[i],HIGH); }
void mux_select(int board, int ch){
  mux_disable_all();
  digitalWrite(PIN_MUX_E[board],LOW);
  delay(1);
  muxAddr(ch);
  delay(8);
}

===== END src/empfaenger/mux.cpp =====

===== BEGIN src/empfaenger/power.h =====
#pragma once
#include <Arduino.h>
#include "config.h"
#include "mux.h"    // für optionalen Check

void power_begin();                 // setzt PIN_BTS sicher LOW
void power_set_24v(bool enable);    // true = 24V an (PIN_BTS=HIGH), false = 24V aus
bool power_is_24v();

===== END src/empfaenger/power.h =====

===== BEGIN src/empfaenger/power.cpp =====
#include "power.h"

static bool s_is24v = false;

void power_begin(){
  pinMode(PIN_BTS, OUTPUT);
  digitalWrite(PIN_BTS, LOW);   // Start immer 24V AUS
  s_is24v = false;
}

// harte Umschaltung mit kleinen Schutzzeiten
void power_set_24v(bool enable){
  if (enable == s_is24v) return;

  if (enable){
    // 24V EIN
    digitalWrite(PIN_BTS, HIGH);
    delay(5);                   // kleiner Guard
    s_is24v = true;
  } else {
    // 24V AUS
    digitalWrite(PIN_BTS, LOW);
    delay(20);                  // Zeit zum Entladen der Rail
    s_is24v = false;
  }
}

bool power_is_24v(){ return s_is24v; }

===== END src/empfaenger/power.cpp =====

===== BEGIN src/empfaenger/radio.h =====
#pragma once
#include <Arduino.h>
#include "config.h"

void radio_begin();             // setzt M0/M1, startet UART
bool radio_ready();             // AUX = HIGH?
void radio_set_normal_mode();   // M1=0, M0=0

===== END src/empfaenger/radio.h =====

===== BEGIN src/empfaenger/radio.cpp =====
#include "radio.h"

void radio_begin(){
  pinMode(RADIO_M0_PIN, OUTPUT);
  pinMode(RADIO_M1_PIN, OUTPUT);
  pinMode(RADIO_AUX_PIN, INPUT);    // ggf. INPUT_PULLUP falls offen
  radio_set_normal_mode();
  // UART1 startet – wenn Modul stromlos ist, stört das nicht
  Serial1.begin(RADIO_BAUD);
}

void radio_set_normal_mode(){
  digitalWrite(RADIO_M0_PIN, LOW);
  digitalWrite(RADIO_M1_PIN, LOW);
  delay(5);
}

bool radio_ready(){
  int lvl = digitalRead(RADIO_AUX_PIN);
  return (lvl != 0); // HIGH=bereit (je nach Modul)
}

===== END src/empfaenger/radio.cpp =====

===== BEGIN src/empfaenger/sense.h =====
#pragma once
#include <Arduino.h>
#include "config.h"

void sense_begin();
void sense_scan_once();                 // aktualisiert LEDs (Latch) und loggt Änderungen
void sense_stop(bool clear_leds);       // Messung „aus“ + LEDs optional löschen
void sense_enable();                    // Messung wieder einschalten
bool sense_is_enabled();
int  sense_count_connected();           // <-- NEU: Anzahl erkannter Kanäle

===== END src/empfaenger/sense.h =====

===== BEGIN src/empfaenger/sense.cpp =====
#include "sense.h"
#include "leds.h"
#include "mux.h"
#include "mapping.h"

static bool    connected[TOTAL_CH] = {0};
static uint8_t ledMask[BOARDS]     = {0,0,0,0};
static bool    sensing_enabled     = true;

static inline float rawToVadc(int raw){ return (raw / ADC_MAX) * VREF_ADC; }
static inline float vadcToVy(float v){ return v * DIV_GAIN; }

void sense_begin(){
  analogReadResolution(ADC_BITS);
  analogReadAveraging(8);
  for(int b=0;b<BOARDS;b++){ ledMask[b]=0; leds_write_board(b,0x00); }
  for(int i=0;i<TOTAL_CH;i++) connected[i]=false;
  sensing_enabled = true;
}

void sense_stop(bool clear_leds){
  sensing_enabled = false;
  mux_disable_all();
  if (clear_leds){
    leds_all_off();
    leds_tristate_outputs(true);   // OE HIGH -> Ausgänge AUS (stromsparend)
  }
}

void sense_enable(){
  sensing_enabled = true;          // LEDs/Masken bleiben bestehen
  leds_tristate_outputs(false);    // sichtbar lassen
}


int sense_count_connected(){
  int n=0;
  for(int i=0;i<TOTAL_CH;i++) if (connected[i]) n++;
  return n;
}

bool sense_is_enabled(){ return sensing_enabled; }

void sense_scan_once(){
  if (!sensing_enabled) return;

  for(int ch=0; ch<TOTAL_CH; ++ch){
    int b = ch / CH_PER, k = ch % CH_PER;

    mux_select(b,k);

    // 8x Mittelwert
    int raw = 0;
    for(int i=0;i<8;i++){ raw += analogRead(PIN_MUX_Z[b]); delayMicroseconds(150); }
    raw /= 8;

    mux_disable_all();

    float vy = vadcToVy(rawToVadc(raw));
    bool prev  = connected[ch];
    bool now   = prev;
    bool clamp = (vy >= TH_ZENER_VY);

    if (!clamp){
      if (raw > RAW_ON)       now = true;
      else if (raw < RAW_OFF) now = false;
    } else now = false;

    if (now != prev){
      connected[ch] = now;

      // LED-Mapping: lokaler Kanal k -> LED-Bit auf Board b
      uint8_t ledBit = LED_MAP[b][k];
      if (now)  ledMask[b] |=  (1u << ledBit);
      else      ledMask[b] &= ~(1u << ledBit);

      leds_write_board(b, ledMask[b]);

      uint8_t zk = ZK_FROM_CH[ch];
      Serial.print("ZK"); Serial.print(zk);
      Serial.print(" (CH"); Serial.print(ch); Serial.print(") -> ");
      Serial.print(now ? "DURCHGANG" : "offen");
      Serial.print("  raw="); Serial.print(raw);
      Serial.print("  Vy=");  Serial.print(vy,3); Serial.println("V");
    }
  }
}

===== END src/empfaenger/sense.cpp =====

===== BEGIN src/sender/ZuendpulsSv1.ino =====
#include <Arduino.h>
#include <cstring>          // für strlen
#include "config.h"
#include "buttons.h"
#include "leds.h"
#include "buzzer.h"
#include "display.h"
#include "battery.h"
#include "heater.h"
#include "radio.h"
#include "rtc.h"

// ===================== BUTTONS =====================
Button btnScharf   { PIN_BTN_SCHARF, true, true, 10, false, false, 0 };
Button btnUp       { PIN_BTN_UP,     true, true, 10, false, false, 0 };
Button btnEnter    { PIN_BTN_ENTER,  true, true, 10, false, false, 0 };
Button btnDown     { PIN_BTN_DOWN,   true, true, 10, false, false, 0 };
Button btnRes[5] = {
  { PIN_BTN_RES1, true, true, 10, false, false, 0 },
  { PIN_BTN_RES2, true, true, 10, false, false, 0 },
  { PIN_BTN_RES3, true, true, 10, false, false, 0 },
  { PIN_BTN_RES4, true, true, 10, false, false, 0 },
  { PIN_BTN_RES5, true, true, 10, false, false, 0 }
};
Button btnStart    { PIN_BTN_START,  true, true, 10, false, false, 0 };

// ===================== LEDs / DISPLAY =====================
LedSet  leds;
Display dsp;

// ===================== RTC / RADIO STATE =====================
RTCX::RtcTime g_rtc;
char g_timeStr[9] = "??:??:??";   // HH:MM:SS
uint32_t g_rtcMs  = 0;

bool     g_radioOk      = false;
uint8_t  g_radioErrCode = 0;      // 0=OK, 1=Version, 2=Params, 3=TX

// ===================== UI STATE =====================
volatile bool g_armed = false;
UiPage   g_page    = UI_BOX;
String   g_lastKey = "none";
uint32_t g_uiTick  = 0;

// ===================== SETUP =====================
void setup() {
  Serial.begin(115200);
  delay(50);

  // Mode-Pins sicher setzen: SLEEP/Config (M1=1, M0=1)
  pinMode(PIN_RADIO_M0, OUTPUT);
  pinMode(PIN_RADIO_M1, OUTPUT);
  digitalWrite(PIN_RADIO_M0, HIGH);
  digitalWrite(PIN_RADIO_M1, HIGH);
  delay(20);

  // Subsysteme
  Buzz::begin();
  leds.begin();
  Battery::begin();
  Heater::begin();
  RTCX::begin();

  // Radio-Basis
  Radio::begin(9600);

  // Selbsttest mit Fehlercode
  Radio::SelfTestResult st = Radio::selfTest(700, 700, 1000);
  g_radioErrCode = static_cast<uint8_t>(st);
  g_radioOk = (st == Radio::ST_OK);

  Serial.printf("Radio selftest: %s (code=%u)\n", g_radioOk ? "OK" : "ERR", g_radioErrCode);

  // Buttons & Display
  btnScharf.begin();
  btnUp.begin(); btnEnter.begin(); btnDown.begin();
  for (auto &b : btnRes) b.begin();
  btnStart.begin();

  dsp.begin();
  dsp.splash("Sender init...");
  Buzz::triple();

  leds.allOff();
  g_armed = false;

  // Uhr ggf. einmalig stellen (nur kurz aktivieren, flashen, dann wieder aus)
  // RTCX::set(2025, 10, 10, 13, 53, 0);
}

// ===================== UI / INPUT =====================
static void handleUi(){
  // Seitenwechsel
  if (btnUp.fell(btnUp.update()))     { g_page = (UiPage)((g_page + UI_MAX - 1) % UI_MAX); g_lastKey = "Up";   Buzz::beep(40); }
  if (btnDown.fell(btnDown.update())) { g_page = (UiPage)((g_page + 1) % UI_MAX);         g_lastKey = "Down"; Buzz::beep(40); }
  if (btnEnter.fell(btnEnter.update())){
    g_lastKey = "Enter";
    Heater::set(!Heater::get());
    Buzz::beep(60);
  }

  // Reserve-Taster LED spiegeln
  for (int i=0;i<5;i++){
    bool edge = btnRes[i].update();
    if (btnRes[i].fell(edge)){
      g_lastKey = String("Res") + String(i+1);
      leds.ledRes[i].toggle();
      Buzz::beep(30);
    }
  }

  // Start/Pause
  if (btnStart.fell(btnStart.update())){
    g_lastKey = "Start";
    leds.ledStart.toggle();
    Buzz::beep(100);
  }

  // Schlüsselschalter (Scharf)
  bool edgeArm = btnScharf.update();
  if (btnScharf.fell(edgeArm)){
    g_armed = true;
    leds.ledScharf.on();
    Buzz::triple();
  } else if (btnScharf.rose(edgeArm)){
    g_armed = false;
    leds.ledScharf.off();
    Buzz::beep(200);
  }
}

// ===================== RTC-STRING =====================
static void updateRtcString(){
  if (RTCX::read(g_rtc) && g_rtc.valid){
    snprintf(g_timeStr, sizeof(g_timeStr), "%02u:%02u:%02u", g_rtc.hour, g_rtc.min, g_rtc.sec);
  } else {
    strncpy(g_timeStr, "--:--:--", sizeof(g_timeStr));
  }
}

// ===================== LOOP =====================
void loop() {
  handleUi();

  // Akku
  float vbat = Battery::readVoltage();
  uint8_t pct = Battery::socPercent(vbat);
  const char* battTxt = Battery::levelText(vbat);

  // RTC alle ~200 ms aktualisieren
  if (millis() - g_rtcMs > 200){
    g_rtcMs = millis();
    updateRtcString();
  }

  // LED: Ein/Aus-Ring spiegelt "armed"
  if (g_armed) leds.ledRingSW.on(); else leds.ledRingSW.off();

  // Display refresh ~100 ms
  if (millis() - g_uiTick > 100){
    g_uiTick = millis();
    dsp.drawStatus(g_page, vbat, pct, battTxt, g_lastKey.c_str(),
                   g_armed, Heater::get(), g_timeStr, g_radioOk, g_radioErrCode);
  }

  delay(1);
}

===== END src/sender/ZuendpulsSv1.ino =====

===== BEGIN src/sender/battery.h =====
#pragma once
#include <Arduino.h>
#include "config.h"

namespace Battery {

  // LiFePO4 4S grobe LUT (Leerlauf/leichte Last). Sehr flache Mitte -> nur Näherung!
  // {Spannung in V, Prozent}
  static constexpr struct { float v; uint8_t p; } LUT[] = {
    {14.40f,100}, {13.60f, 95}, {13.40f, 90}, {13.30f, 85},
    {13.20f, 80}, {13.10f, 70}, {13.00f, 60}, {12.90f, 50},
    {12.80f, 40}, {12.70f, 30}, {12.60f, 20}, {12.40f, 15},
    {12.20f, 10}, {12.00f,  7}, {11.80f,  5}, {11.60f,  0}
  };

  // einfacher gleitender Mittelwert
  static float v_filtered = 0.0f;
  static const uint8_t avgSamples = 8;

  inline void begin(){
    analogReadResolution(ADC_BITS);
    analogReadAveraging(avgSamples);     // Teensy-Hardware-Averaging
    pinMode(PIN_ADC_BATT, INPUT);        // stabil & portable
  }

  inline float readVoltageRaw(){
    uint16_t raw = analogRead(PIN_ADC_BATT);
    float vin = ( (float)raw / ADC_COUNTS ) * ADC_VREF * BATT_DIV_FACTOR;
    // Kalibrierung anwenden
    vin = vin * BATT_CAL_SCALE + BATT_CAL_OFFSET;
    return vin;
  }

  inline float readVoltage(){
    float v = readVoltageRaw();
    if (v_filtered <= 0.01f) v_filtered = v;               // initialisieren
    v_filtered = v_filtered * 0.7f + v * 0.3f;             // EMA
    return v_filtered;
  }

  inline uint8_t socPercent(float v){
    // über/unter LUT kappen
    if (v >= LUT[0].v) return 100;
    if (v <= LUT[sizeof(LUT)/sizeof(LUT[0]) - 1].v) return 0;
    // Interpolation zwischen Stützstellen
    for (size_t i=0; i< (sizeof(LUT)/sizeof(LUT[0]) - 1); ++i){
      if (v >= LUT[i+1].v && v <= LUT[i].v){
        float x0=LUT[i].v,   y0=LUT[i].p;
        float x1=LUT[i+1].v, y1=LUT[i+1].p;
        float t = (v - x1) / (x0 - x1); // 0..1
        float p = y1 + t * (y0 - y1);
        if (p<0) p=0; if (p>100) p=100;
        return (uint8_t)(p + 0.5f);
      }
    }
    return 0;
  }

  inline const char* levelText(float v){
    if (v <= BATT_CRIT_V) return "LOW!";
    if (v <= BATT_WARN_V) return "Warn";
    return "OK";
  }
}

===== END src/sender/battery.h =====

===== BEGIN src/sender/battery.cpp =====
#include "battery.h"
// (inline)

===== END src/sender/battery.cpp =====

===== BEGIN src/sender/buttons.h =====
#pragma once
#include <Arduino.h>

struct Button {
  uint8_t pin;
  bool    pullup;       // INPUT_PULLUP?
  bool    invert;       // LOW = pressed
  uint16_t debounce_ms; // stabiler Zeitraum
  bool    state;        // aktueller stabiler Zustand
  bool    lastState;
  uint32_t lastChange;

  void begin() {
    pinMode(pin, pullup ? INPUT_PULLUP : INPUT);
    bool raw = digitalRead(pin);
    state = lastState = invert ? !raw : raw;
    lastChange = millis();
  }

  // returns true on rising/falling edges
  bool update() {
    bool raw = digitalRead(pin);
    bool logical = invert ? !raw : raw;
    if (logical != lastState) {
      // potenzieller Wechsel -> Timer setzen
      if (millis() - lastChange >= debounce_ms) {
        lastChange = millis();
        lastState = logical;
        state = logical;
        return true; // Edge bestätigt
      }
    } else {
      lastChange = millis(); // stabil
    }
    return false;
  }

  bool pressed() const { return state; }
  bool fell(bool currentEdge) const {
    // pressed edge (von false -> true)
    // das prüfen in der Loop: wenn currentEdge und pressed()==true
    return currentEdge && state == true;
  }
  bool rose(bool currentEdge) const {
    return currentEdge && state == false;
  }
};

===== END src/sender/buttons.h =====

===== BEGIN src/sender/buttons.cpp =====
#include "buttons.h"
// (leer – alles inline in struct. Platzhalter für evtl. Gruppenfunktionen)

===== END src/sender/buttons.cpp =====

===== BEGIN src/sender/buzzer.h =====
#pragma once
#include <Arduino.h>
#include "config.h"

namespace Buzz {
  inline void begin(){ pinMode(PIN_BUZZER, OUTPUT); digitalWrite(PIN_BUZZER, LOW); }
  inline void beep(uint16_t ms){ digitalWrite(PIN_BUZZER, HIGH); delay(ms); digitalWrite(PIN_BUZZER, LOW); }
  inline void triple(){ beep(80); delay(80); beep(80); delay(80); beep(120); }
}

===== END src/sender/buzzer.h =====

===== BEGIN src/sender/buzzer.cpp =====
#include "buzzer.h"
// (inline)

===== END src/sender/buzzer.cpp =====

===== BEGIN src/sender/config.h =====
#pragma once
#include <Arduino.h>

// ====== PINS laut Deiner Liste ======
// Funkmodul (E32-433T33S)
constexpr uint8_t PIN_RADIO_RX   = 0;   // UART RX (Teensy)
constexpr uint8_t PIN_RADIO_TX   = 1;   // UART TX
constexpr uint8_t PIN_RADIO_AUX  = 2;
constexpr uint8_t PIN_RADIO_M0   = 3;
constexpr uint8_t PIN_RADIO_M1   = 4;

// Buzzer
constexpr uint8_t PIN_BUZZER     = 6;

// OLED (SSD1309 SPI)
constexpr uint8_t PIN_OLED_RES   = 7;
constexpr uint8_t PIN_OLED_DC    = 8;
constexpr uint8_t PIN_OLED_CS    = 9;
constexpr uint8_t PIN_OLED_MOSI  = 11;
constexpr uint8_t PIN_OLED_SCK   = 13;

// LED Ringe / LEDs
constexpr uint8_t PIN_LED_RING_SW     = 10; // Ein/Aus-Schalter LED-Ring
constexpr uint8_t PIN_LED_SCHARF      = 21; // "Armed" LED
constexpr uint8_t PIN_LED_UP          = 27;
constexpr uint8_t PIN_LED_ENTER       = 28;
constexpr uint8_t PIN_LED_DOWN        = 29;
constexpr uint8_t PIN_LED_RES1        = 30;
constexpr uint8_t PIN_LED_RES2        = 31;
constexpr uint8_t PIN_LED_RES3        = 32;
constexpr uint8_t PIN_LED_RES4        = 33;
constexpr uint8_t PIN_LED_RES5        = 34;
constexpr uint8_t PIN_LED_START       = 41;

// Taster
constexpr uint8_t PIN_BTN_SCHARF      = 22; // Schlüsselschalter (digital gelesen)
constexpr uint8_t PIN_BTN_UP          = 24;
constexpr uint8_t PIN_BTN_ENTER       = 25;
constexpr uint8_t PIN_BTN_DOWN        = 26;
constexpr uint8_t PIN_BTN_RES1        = 35;
constexpr uint8_t PIN_BTN_RES2        = 36;
constexpr uint8_t PIN_BTN_RES3        = 37;
constexpr uint8_t PIN_BTN_RES4        = 38;
constexpr uint8_t PIN_BTN_RES5        = 39;
constexpr uint8_t PIN_BTN_START       = 40;

// Messungen / Aktoren
constexpr uint8_t PIN_ADC_BATT        = 14; // A0
constexpr uint8_t PIN_ADC_HEATER      = 15; // ADC für Heizungssensor
constexpr uint8_t PIN_HEATER_EN       = 16; // Heizung On/Off

// RTC (I2C)
constexpr uint8_t PIN_RTC_SDA         = 18;
constexpr uint8_t PIN_RTC_SCL         = 19;

// ====== Konstanten ======
constexpr float    ADC_VREF           = 3.3f;
constexpr uint16_t ADC_BITS           = 12;      // Teensy kann 12 Bit sauber
constexpr float    ADC_COUNTS         = (1 << ADC_BITS) - 1; // 4095

// Batterie-Teiler: 33k (R1 oben) + 10k (R2 unten) -> Faktor = (R1+R2)/R2
constexpr float    BATT_R1_KOHM       = 33.0f;
constexpr float    BATT_R2_KOHM       = 10.0f;
constexpr float    BATT_DIV_FACTOR    = (BATT_R1_KOHM + BATT_R2_KOHM) / BATT_R2_KOHM; // 4.3

// ====== LiFePO4 (4S) Grenzwerte ======
// Voll ~14.4–14.6 V (unter Last meist ~13.6–14.0 V), sehr flache Kurve.
// Warnen ab ~12.4 V (≈ ~20–30%), kritisch ab ~11.6 V (~3.0 V/Zelle).
constexpr float    BATT_WARN_V        = 12.4f;
constexpr float    BATT_CRIT_V        = 11.6f;

// Kalibrierung (optional):
// Wenn Multimeter z.B. 12.80 V zeigt, Code aber 12.60 V:
// -> BATT_CAL_SCALE = 12.80/12.60 = 1.0159
constexpr float    BATT_CAL_SCALE     = 1.000f;  // Multiplikation
constexpr float    BATT_CAL_OFFSET    = 0.00f;   // Addition (in Volt)

enum UiPage : uint8_t { UI_BOX = 0, UI_BATT = 1, UI_COUNT = 2, UI_MAX = 3 };

// kleine Helfer
template<typename T, size_t N>
constexpr size_t array_len(const T (&)[N]) { return N; }

===== END src/sender/config.h =====

===== BEGIN src/sender/display.h =====
#pragma once
#include <Arduino.h>
#include <U8g2lib.h>
#include "config.h"

class Display {
public:
  Display();
  void begin();
  void splash(const char* line = "Display OK");

  // Achtung: Signatur inkl. radioOk & radioErrCode!
  void drawStatus(UiPage page,
                  float battV, uint8_t battPct, const char* battTxt,
                  const char* lastKey, bool armed, bool heaterOn,
                  const char* timeHHMMSS, bool radioOk, uint8_t radioErrCode);

private:
  U8G2* u8g2; // wird in begin() alloziert
};

===== END src/sender/display.h =====

===== BEGIN src/sender/display.cpp =====
#include "display.h"
#include <SPI.h>

Display::Display() : u8g2(nullptr) {}

void Display::begin() {
  // SSD1309 (128x64) SPI, Pins aus config.h
  u8g2 = new U8G2_SSD1309_128X64_NONAME2_F_4W_HW_SPI(
    U8G2_R0,         // Rotation
    PIN_OLED_CS,     // CS
    PIN_OLED_DC,     // DC
    PIN_OLED_RES     // RESET
  );
  u8g2->begin();
}

void Display::splash(const char* line) {
  if (!u8g2) return;
  u8g2->clearBuffer();
  u8g2->setFont(u8g2_font_6x12_tr);
  u8g2->drawStr(0, 14, line);
  u8g2->sendBuffer();
}

void Display::drawStatus(UiPage page,
                         float battV, uint8_t battPct, const char* battTxt,
                         const char* lastKey, bool armed, bool heaterOn,
                         const char* timeHHMMSS, bool radioOk, uint8_t radioErrCode)
{
  if (!u8g2) return;

  u8g2->clearBuffer();
  u8g2->setFont(u8g2_font_6x12_tr);

  // Header: Titel links
  u8g2->drawStr(0, 12, "Sender UI");

  // Header: Uhr rechts (Breite grob 8 Zeichen à 6px = 48px)
  if (timeHHMMSS) {
    const int w = 6 * 8;
    u8g2->drawStr(128 - w, 12, timeHHMMSS);
  }

  // Zeile 2: Page + ARM
  char top[40];
  snprintf(top, sizeof(top), "Page:%u  ARM:%s", (unsigned)page, armed ? "ON" : "OFF");
  u8g2->drawStr(0, 24, top);

  if (page == UI_BOX) {
    if (radioOk) {
      u8g2->drawStr(0, 38, "Box: Radio OK");
    } else {
      char ln[28];
      snprintf(ln, sizeof(ln), "Box: Radio ERR(%u)", radioErrCode);
      u8g2->drawStr(0, 38, ln);
    }
    char ln2[28];
    snprintf(ln2, sizeof(ln2), "Heater:%s", heaterOn ? "ON" : "OFF");
    u8g2->drawStr(0, 50, ln2);

  } else if (page == UI_BATT) {
    // Batterie-Text
    char ln1[48];
    snprintf(ln1, sizeof(ln1), "Batt: %.2f V  %u%%  [%s]", battV, battPct, battTxt ? battTxt : "");
    u8g2->drawStr(0, 38, ln1);

    // Batterie-Balken (100x10)
    const int x = 0, y = 52, w = 100, h = 10;
    u8g2->drawFrame(x, y - h, w, h);
    int fill = (w * battPct) / 100;
    if (fill > 0) {
      int inner = fill - 2;
      if (inner < 0) inner = 0;
      u8g2->drawBox(x + 1, y - h + 1, inner, h - 2);
    }

  } else if (page == UI_COUNT) {
    u8g2->drawStr(0, 38, "Count/Info Seite");
    char ln[48];
    snprintf(ln, sizeof(ln), "Letzter Taster: %s", lastKey ? lastKey : "none");
    u8g2->drawStr(0, 50, ln);
  }

  u8g2->sendBuffer();
}

===== END src/sender/display.cpp =====

===== BEGIN src/sender/leds.h =====
#pragma once
#include <Arduino.h>
#include "config.h"

struct Led {
  uint8_t pin;
  void begin() { pinMode(pin, OUTPUT); off(); }
  void on()    { digitalWrite(pin, HIGH); }
  void off()   { digitalWrite(pin, LOW); }
  void toggle(){ digitalWrite(pin, !digitalRead(pin)); }
};

struct LedSet {
  Led ledRingSW, ledScharf, ledUp, ledEnter, ledDown, ledRes[5], ledStart;

  void begin() {
    ledRingSW.pin = PIN_LED_RING_SW; ledRingSW.begin();
    ledScharf.pin = PIN_LED_SCHARF;  ledScharf.begin();
    ledUp.pin     = PIN_LED_UP;      ledUp.begin();
    ledEnter.pin  = PIN_LED_ENTER;   ledEnter.begin();
    ledDown.pin   = PIN_LED_DOWN;    ledDown.begin();
    uint8_t resPins[5] = {PIN_LED_RES1, PIN_LED_RES2, PIN_LED_RES3, PIN_LED_RES4, PIN_LED_RES5};
    for (int i=0;i<5;i++){ ledRes[i].pin = resPins[i]; ledRes[i].begin(); }
    ledStart.pin  = PIN_LED_START;   ledStart.begin();
  }

  void allOff(){
    ledRingSW.off(); ledScharf.off(); ledUp.off(); ledEnter.off(); ledDown.off();
    for (auto &l : ledRes) l.off();
    ledStart.off();
  }
};

===== END src/sender/leds.h =====

===== BEGIN src/sender/leds.cpp =====
#include "leds.h"
// (Logik inlined)

===== END src/sender/leds.cpp =====

===== BEGIN src/sender/radio.h =====
#pragma once
#include <Arduino.h>
#include <stdint.h>
#include "config.h"

namespace Radio {

  enum Mode : uint8_t { MODE_NORMAL=0, MODE_WAKEUP=1, MODE_POWER_SAVING=2, MODE_SLEEP=3 };

  struct Version {
    bool ok{false};
    uint8_t ver{0};    // z.B. 0x32
    uint8_t module{0}; // 0x46/0x47 etc.
    uint8_t freq{0};   // 0x32=433, 0x64=868, 0xC8=915
  };

  struct Params {
    bool ok{false};
    uint8_t ADDH{0}, ADDL{0}, SPED{0}, CHAN{0}, OPTION{0};
  };

  enum SelfTestResult : uint8_t {
    ST_OK = 0,
    ST_ERR_VERSION = 1,
    ST_ERR_PARAMS  = 2,
    ST_ERR_TX      = 3
  };

  // Basis
  void begin(uint32_t baud=9600);
  void setMode(Mode m);
  bool waitAux(uint32_t timeout_ms=500);
  bool auxLevel();

  // Abfragen
  Version readVersion(uint32_t timeout_ms=700);
  Params  readParams(uint32_t timeout_ms=1200);

  // TX-Test
  bool    sendTestPacket(const uint8_t* data, size_t len, uint32_t timeout_ms=800);

  // Selbsttest (Version -> Params -> Test-TX)
  SelfTestResult selfTest(uint32_t ver_to_ms = 700, uint32_t par_to_ms = 1200, uint32_t tx_to_ms = 1000);

} // namespace Radio

===== END src/sender/radio.h =====

===== BEGIN src/sender/radio.cpp =====
#include "radio.h"
#include <cstring> // strlen

namespace {
  inline void pinWrite(uint8_t p, bool hi){ digitalWrite(p, hi?HIGH:LOW); }
  inline bool pinRead(uint8_t p){ return digitalRead(p); }

  const uint8_t CMD_READ_VERSION[3] = {0xC3,0x00,0x08};
  const uint8_t CMD_READ_PARAMS [3] = {0xC1,0x00,0x09};

  void clearSerial(HardwareSerial& s){
    while (s.available()) (void)s.read();
  }

  size_t readBytesTimeout(HardwareSerial& s, uint8_t* buf, size_t len, uint32_t to_ms){
    uint32_t start = millis(); size_t got = 0;
    while (got < len && (millis() - start) < to_ms){
      if (s.available()){
        buf[got++] = (uint8_t)s.read();
      } else {
        yield();
      }
    }
    return got;
  }

  // Suche nach Sequenz C1 00 09 im Puffer
  int findParamsHeader(const uint8_t* b, int n){
    for (int i=0; i<=n-3; ++i){
      if (b[i]==0xC1 && b[i+1]==0x00 && b[i+2]==0x09) return i;
    }
    return -1;
  }
}

namespace Radio {

  void begin(uint32_t baud){
    pinMode(PIN_RADIO_M0, OUTPUT);
    pinMode(PIN_RADIO_M1, OUTPUT);
    pinMode(PIN_RADIO_AUX, INPUT);

    // Start in SLEEP/Config (M1=1, M0=1)
    pinWrite(PIN_RADIO_M0, HIGH);
    pinWrite(PIN_RADIO_M1, HIGH);
    delay(20);

    Serial1.begin(baud);
    delay(60);
    waitAux(1000);
    clearSerial(Serial1);
  }

  bool auxLevel(){ return pinRead(PIN_RADIO_AUX); }

  void setMode(Mode m){
    switch(m){
      case MODE_NORMAL:       pinWrite(PIN_RADIO_M1, LOW);  pinWrite(PIN_RADIO_M0, LOW);  break;
      case MODE_WAKEUP:       pinWrite(PIN_RADIO_M1, LOW);  pinWrite(PIN_RADIO_M0, HIGH); break;
      case MODE_POWER_SAVING: pinWrite(PIN_RADIO_M1, HIGH); pinWrite(PIN_RADIO_M0, LOW);  break;
      case MODE_SLEEP:        pinWrite(PIN_RADIO_M1, HIGH); pinWrite(PIN_RADIO_M0, HIGH); break;
    }
    delay(12);
    waitAux(1000);
    clearSerial(Serial1);
  }

  bool waitAux(uint32_t timeout_ms){
    uint32_t t0 = millis();
    while ((millis()-t0) < timeout_ms){
      if (pinRead(PIN_RADIO_AUX)) return true;
    }
    return false;
  }

  Version readVersion(uint32_t timeout_ms){
    Version v;
    setMode(MODE_SLEEP);
    clearSerial(Serial1);

    Serial1.write(CMD_READ_VERSION, 3);
    Serial1.flush();
    delay(10); // kleinen Moment geben

    uint8_t buf[8] = {0};
    size_t n = readBytesTimeout(Serial1, buf, sizeof(buf), timeout_ms);

    if (n >= 4 && buf[0] == 0xC3){
      v.ok     = true;
      v.ver    = buf[1];
      v.module = buf[2];
      v.freq   = buf[3];
    }
    return v;
  }

  Params readParams(uint32_t timeout_ms){
    Params p;
    setMode(MODE_SLEEP);
    clearSerial(Serial1);

    Serial1.write(CMD_READ_PARAMS, 3);
    Serial1.flush();
    delay(10);

    // Wir wissen nicht genau, wie lang die Antwort ausfällt:
    // daher großzügiger Puffer und dann nach Header scannen.
    uint8_t tmp[32] = {0};
    size_t n = readBytesTimeout(Serial1, tmp, sizeof(tmp), timeout_ms);

    // Versuch 1: Header suchen (C1 00 09)
    int k = findParamsHeader(tmp, (int)n);
    if (k >= 0){
      // danach sollten mind. 6 Nutzbytes kommen
      if (k + 9 <= (int)n){
        p.ADDH   = tmp[k+3];
        p.ADDL   = tmp[k+4];
        p.SPED   = tmp[k+5];
        p.CHAN   = tmp[k+6];
        p.OPTION = tmp[k+7];
        p.ok = true;
        return p;
      }
    }

    // Versuch 2: Einige Module liefern nur 6 Bytes (ohne Header) direkt.
    if (n == 6){
      p.ADDH   = tmp[0];
      p.ADDL   = tmp[1];
      p.SPED   = tmp[2];
      p.CHAN   = tmp[3];
      p.OPTION = tmp[4];
      p.ok = true;
      return p;
    }

    // Versuch 3: Wenn >=6 Bytes insgesamt, nimm die letzten 6 als Payload.
    if (n >= 6){
      p.ADDH   = tmp[n-6];
      p.ADDL   = tmp[n-5];
      p.SPED   = tmp[n-4];
      p.CHAN   = tmp[n-3];
      p.OPTION = tmp[n-2];
      p.ok = true;
      return p;
    }

    // sonst: fail
    p.ok = false;
    return p;
  }

  bool sendTestPacket(const uint8_t* data, size_t len, uint32_t timeout_ms){
    setMode(MODE_NORMAL);
    size_t sent = Serial1.write(data, len);
    Serial1.flush();
    // Warte bis AUX wieder HIGH (TX fertig)
    return (sent == len) && waitAux(timeout_ms);
  }

  SelfTestResult selfTest(uint32_t ver_to_ms, uint32_t par_to_ms, uint32_t tx_to_ms){
    Version rv = readVersion(ver_to_ms);
    if (!rv.ok) return ST_ERR_VERSION;

    Params rp = readParams(par_to_ms);
    if (!rp.ok) return ST_ERR_PARAMS;

    const char* msg = "SENDER-HELLO";
    bool txok = sendTestPacket((const uint8_t*)msg, strlen(msg), tx_to_ms);
    if (!txok) return ST_ERR_TX;

    return ST_OK;
  }

} // namespace Radio

===== END src/sender/radio.cpp =====

===== BEGIN src/sender/rtc.h =====
#pragma once
#include <Arduino.h>
#include <Wire.h>
#include "config.h"

namespace RTCX {

struct RtcTime {
  uint8_t sec{0}, min{0}, hour{0}, day{1}, month{1};
  uint16_t year{2000};
  bool valid{false};
};

inline uint8_t bcd2bin(uint8_t v){ return v - 6 * (v >> 4); }
inline uint8_t bin2bcd(uint8_t v){ return v + 6 * (v / 10); }

inline void begin(){
  // Teensy 4.x: Standard I2C-Pins (SDA=18, SCL=19)
  Wire.begin();
  Wire.setClock(400000); // 400kHz okay für DS3231
}

// Liest Zeit aus DS3231 @ 0x68
inline bool read(RtcTime &t){
  Wire.beginTransmission(0x68);
  Wire.write((uint8_t)0x00); // Sek.-Register
  if (Wire.endTransmission(false) != 0) return t.valid = false, false;

  // 7 Bytes: sec, min, hour, dow, day, month, year
  if (Wire.requestFrom(0x68, 7u) != 7) return t.valid = false, false;

  uint8_t sec   = Wire.read();
  uint8_t min   = Wire.read();
  uint8_t hour  = Wire.read();
  (void)Wire.read();             // Wochentag ignorieren
  uint8_t mday  = Wire.read();
  uint8_t month = Wire.read();
  uint8_t year  = Wire.read();

  // Stunden: 12/24h Bit6 in hour; wir erzwingen 24h
  if (hour & 0x40){              // 12h-Format
    bool pm = hour & 0x20;
    hour = bcd2bin(hour & 0x1F);
    if (pm && hour < 12) hour += 12;
    if (!pm && hour == 12) hour = 0;
  } else {
    hour = bcd2bin(hour & 0x3F);
  }

  t.sec   = bcd2bin(sec & 0x7F);
  t.min   = bcd2bin(min & 0x7F);
  t.hour  = hour;
  t.day   = bcd2bin(mday & 0x3F);
  t.month = bcd2bin(month & 0x1F);
  t.year  = 2000 + bcd2bin(year);
  t.valid = true;
  return true;
}

// Optional: Uhr stellen (24h)
inline bool set(uint16_t y, uint8_t m, uint8_t d, uint8_t hh, uint8_t mm, uint8_t ss){
  if (y < 2000) y = 2000;
  Wire.beginTransmission(0x68);
  Wire.write((uint8_t)0x00);
  Wire.write(bin2bcd(ss));
  Wire.write(bin2bcd(mm));
  Wire.write(bin2bcd(hh));     // 24h
  Wire.write((uint8_t)0x01);   // Wochentag dummy
  Wire.write(bin2bcd(d));
  Wire.write(bin2bcd(m));
  Wire.write(bin2bcd((uint8_t)(y - 2000)));
  return Wire.endTransmission() == 0;
}

} // namespace RTCX

===== END src/sender/rtc.h =====

===== BEGIN src/sender/rtc.cpp =====
#include "rtc.h"
// später: Zeit lesen/schreiben

===== END src/sender/rtc.cpp =====

===== BUNDLE_BUILT_AT: 2025-10-20T10:11:19.428844Z =====
